#include "MalwareExtractor.h"

MalwareExtractor::MalwareExtractor()
{
	m_imagecopy = NULL;
	m_thread = NULL;
	m_module = NULL;
	m_running = 0;
	m_error_code = 0;
}


MalwareExtractor::~MalwareExtractor()
{
	if (m_imagecopy != NULL)
		delete [] m_imagecopy;
}


int MalwareExtractor::Initialize()
{
	m_thread = Findthread(Getcputhreadid());
	if (m_thread == NULL) {
		m_error_code = ME_ERROR_NOTHREAD;
		return -1;
	}

	m_module = Findmodule(m_thread->reg.ip);
	m_imagecopy = new uchar[m_module->size];
	if (m_imagecopy == NULL) {
		m_error_code = ME_ERROR_MEMALLOC;
		return -1;
	}

	if (Readmemory(m_imagecopy, m_module->base, m_module->size, MM_RESTORE) == 0) {
		m_error_code = ME_ERROR_MEMREAD;
		return -1;
	}

	this->BackupModuleRanges();

	m_running = 1;
	return 0;
}


void MalwareExtractor::BackupModuleRanges()
{
	ME_MODULE_RANGE range;
	t_table *module_table = (t_table *) Plugingetvalue (VAL_MODULES);
	t_module *modules = (t_module *) module_table->data.data;

	for (int i = 0; i < module_table->data.n; i++) {
		if (modules[i].base != m_module->base) {
			range.base = modules[i].base;
			range.size = modules[i].size;
			m_module_ranges.push_back(range);
		}
	}
}


void MalwareExtractor::Reset()
{
	m_imagecopy = NULL;
	m_thread = NULL;
	m_module = NULL;
	m_running = 0;
	m_error_code = ME_ERROR_NOERROR;
	m_module_ranges.clear();
	if (m_imagecopy != NULL)
		delete [] m_imagecopy;
}

int MalwareExtractor::FindNextAddress(ulong start)
{
	// At this point we have to analyze memory from current EIP
	// till the end of the current procedure and construct CFG. Then CFG
	// must be normalized in order to reduce number of breakpoints.
	// (up to first control flow change instruction, such as
	// jmp, ret, jcc (conditional jumps). If there are any calls)
	//
	//Error("%08x", m_thread->reg.ip);
	start = m_thread->reg.ip;
	ulong index = start - m_module->base;
	if (index < 0 || index > m_module->size) {
		m_error_code = ME_ERROR_OUTOFBOUNDS;
		return -1;
	}

	uchar *ptr = &m_imagecopy[index];
	ulong end_addr = (ulong)(&m_imagecopy + m_module->size);
	ulong cmd_size;
	ulong ip = start;//m_thread->reg.ip;
	t_disasm dasm = {0};

	// C_JMP = 0x50, C_JMC = 0x60, C_CAL = 0x70, C_RET = 0x80
	while ((dasm.cmdtype < C_JMP || dasm.cmdtype > C_RET) && (ulong)ptr < end_addr) {
		cmd_size = Disasm(ptr, MAXCMDSIZE, ip, NULL, &dasm, DISASM_ALL,
						  m_thread->threadid);
		ptr += cmd_size;
		ip += cmd_size;
	}

	if ((ulong)ptr > end_addr) {
		m_error_code = ME_ERROR_NOTFOUND;
		return -1;
	}

	m_next_address = ip - cmd_size;
	Error("%08X", m_next_address);
	return 0;
}


int MalwareExtractor::IsRunning()
{
	return m_running;
}


int MalwareExtractor::GetErrorCode()
{
	return m_error_code;
}